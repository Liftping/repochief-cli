#!/usr/bin/env node
/**
 * RepoCHief Production API Setup
 * Configures real API keys and removes mock mode restrictions
 */

const fs = require('fs').promises;
const path = require('path');
const inquirer = require('inquirer');
const chalk = require('chalk');

class ProductionAPISetup {
  constructor() {
    this.envPaths = [
      'repochief-core/.env',
      'repochief-cli/.env',
      'repochief-cloud-api/.env',
      'repochief-dashboard/.env.local',
      '.env' // Root level
    ];
  }

  async run() {
    console.log(chalk.cyan('\nüöÄ RepoCHief Production API Setup\n'));
    
    try {
      // Check current configuration
      await this.checkCurrentSetup();
      
      // Get API keys from user
      const apiKeys = await this.getAPIKeys();
      
      // Configure environment files
      await this.configureEnvironments(apiKeys);
      
      // Test API connections
      await this.testAPIConnections(apiKeys);
      
      // Update mock mode settings
      await this.updateMockSettings();
      
      console.log(chalk.green('\n‚úÖ Production API setup complete!'));
      console.log(chalk.gray('RepoCHief is now ready for production usage with real AI APIs.\n'));
      
    } catch (error) {
      console.error(chalk.red('\n‚ùå Setup failed:'), error.message);
      process.exit(1);
    }
  }

  async checkCurrentSetup() {
    console.log(chalk.yellow('üìã Checking current configuration...\n'));
    
    for (const envPath of this.envPaths) {
      try {
        const fullPath = path.join(__dirname, envPath);
        const exists = await fs.access(fullPath).then(() => true).catch(() => false);
        const status = exists ? chalk.green('‚úÖ') : chalk.gray('‚ûñ');
        console.log(`   ${status} ${envPath}`);
      } catch (error) {
        // File doesn't exist, that's okay
      }
    }
    console.log();
  }

  async getAPIKeys() {
    const questions = [
      {
        type: 'password',
        name: 'openaiKey',
        message: 'Enter your OpenAI API key (or leave blank to skip):',
        mask: '*'
      },
      {
        type: 'password',
        name: 'anthropicKey', 
        message: 'Enter your Anthropic API key (or leave blank to skip):',
        mask: '*'
      },
      {
        type: 'password',
        name: 'googleKey',
        message: 'Enter your Google AI API key (or leave blank to skip):',
        mask: '*'
      }
    ];

    const answers = await inquirer.prompt(questions);

    if (!answers.openaiKey && !answers.anthropicKey && !answers.googleKey) {
      throw new Error('At least one API key is required for production usage');
    }

    return answers;
  }

  async configureEnvironments(apiKeys) {
    console.log(chalk.yellow('‚öôÔ∏è  Configuring environment files...\n'));

    // Base environment configuration
    const envContent = this.generateEnvContent(apiKeys);

    // Configure each package
    for (const envPath of this.envPaths) {
      try {
        const fullPath = path.join(__dirname, envPath);
        const dir = path.dirname(fullPath);
        
        // Ensure directory exists
        await fs.mkdir(dir, { recursive: true });
        
        // Write or update .env file
        await fs.writeFile(fullPath, envContent);
        console.log(chalk.green(`   ‚úÖ ${envPath}`));
        
      } catch (error) {
        console.log(chalk.yellow(`   ‚ö†Ô∏è  ${envPath} (${error.message})`));
      }
    }
    console.log();
  }

  generateEnvContent(apiKeys) {
    return `# RepoCHief Production API Configuration
# Generated by setup-production-apis.js

# AI API Keys
${apiKeys.openaiKey ? `OPENAI_API_KEY=${apiKeys.openaiKey}` : '# OPENAI_API_KEY=your-key-here'}
${apiKeys.anthropicKey ? `ANTHROPIC_API_KEY=${apiKeys.anthropicKey}` : '# ANTHROPIC_API_KEY=your-key-here'}  
${apiKeys.googleKey ? `GOOGLE_API_KEY=${apiKeys.googleKey}` : '# GOOGLE_API_KEY=your-key-here'}

# Production Mode
MOCK_MODE=false
NODE_ENV=production

# Budget Controls
TOTAL_BUDGET=100
DAILY_BUDGET=50
PER_TASK_BUDGET=10

# RepoCHief Cloud Services
CLOUD_API_URL=https://api.repochief.com
CLOUD_DASHBOARD_ENABLED=true

# Performance Settings
MAX_CONCURRENT_AGENTS=10
MAX_TASKS_PER_AGENT=3
TASK_TIMEOUT_MS=300000

# Logging
LOG_LEVEL=info
LOG_TO_FILE=true
DEBUG=false
`;
  }

  async testAPIConnections(apiKeys) {
    console.log(chalk.yellow('üîç Testing API connections...\n'));

    // Test OpenAI
    if (apiKeys.openaiKey) {
      try {
        const OpenAI = require('openai');
        const openai = new OpenAI({ apiKey: apiKeys.openaiKey });
        
        const response = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          messages: [{ role: 'user', content: 'Hello' }],
          max_tokens: 5
        });
        
        console.log(chalk.green('   ‚úÖ OpenAI API - Connected successfully'));
      } catch (error) {
        console.log(chalk.red(`   ‚ùå OpenAI API - ${error.message}`));
      }
    }

    // Test Anthropic
    if (apiKeys.anthropicKey) {
      try {
        const { Anthropic } = require('@anthropic-ai/sdk');
        const anthropic = new Anthropic({ apiKey: apiKeys.anthropicKey });
        
        const response = await anthropic.messages.create({
          model: 'claude-3-haiku-20240307',
          messages: [{ role: 'user', content: 'Hello' }],
          max_tokens: 5
        });
        
        console.log(chalk.green('   ‚úÖ Anthropic API - Connected successfully'));
      } catch (error) {
        console.log(chalk.red(`   ‚ùå Anthropic API - ${error.message}`));
      }
    }

    // Test Google AI (if available)
    if (apiKeys.googleKey) {
      console.log(chalk.gray('   ‚ûñ Google AI API - Skipping test (requires additional setup)'));
    }
    
    console.log();
  }

  async updateMockSettings() {
    console.log(chalk.yellow('üîß Updating mock mode settings...\n'));

    // Find and update files that force mock mode
    const filesToUpdate = [
      'repochief-cli/src/commands/run.js',
      'repochief-core/src/core/AIAgentOrchestrator.js'
    ];

    for (const filePath of filesToUpdate) {
      try {
        const fullPath = path.join(__dirname, filePath);
        let content = await fs.readFile(fullPath, 'utf8');
        
        // Remove hardcoded mock mode
        const updated = content.replace(/mockMode:\s*true/g, 'mockMode: false');
        
        if (content !== updated) {
          await fs.writeFile(fullPath, updated);
          console.log(chalk.green(`   ‚úÖ Updated ${filePath}`));
        } else {
          console.log(chalk.gray(`   ‚ûñ ${filePath} (no changes needed)`));
        }
        
      } catch (error) {
        console.log(chalk.yellow(`   ‚ö†Ô∏è  ${filePath} (${error.message})`));
      }
    }
    console.log();
  }
}

// Main execution
if (require.main === module) {
  const setup = new ProductionAPISetup();
  setup.run();
}

module.exports = ProductionAPISetup;